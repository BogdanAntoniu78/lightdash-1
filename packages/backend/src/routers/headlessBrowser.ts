import express from 'express';
import fetch from 'node-fetch';
import passport from 'passport';
import { lightdashConfig } from '../config/lightdashConfig';
import { userModel } from '../models/models';
import { UserModel } from '../models/UserModel';
// var signature = require('cookie-signature')
// var cookie = require('cookie');
const puppeteer = require('puppeteer');

export const headlessBrowserRouter = express.Router({ mergeParams: true });

export const getConnectionSid = async (userUuid: string) => {
    // https://stackoverflow.com/questions/35364954/how-to-access-expressjs-session-cookie-serverside-before-responding
    // https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L542
    // https://stackoverflow.com/questions/56197087/what-is-the-additional-information-in-connect-sid-cookie-string-apart-from-the-s
    // https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L655

    // s%3AjmZ9o7bD8vJaNcoZc5RVVzZyObcxpRSR.Bu1gVgjLUFnXeXtbAVpoUCMX4n6%2FQMMrx2GJBY3U94c
    // s%3Ahiv70GUzGlP2Kj6ONh-KI8I9ktmrj3J8.hv0YcV2ET4SgLoScBbo9AYRRfDgJSciRvLMom7SMwIE
    const sessionUser = await userModel.findSessionUserByUUID(
        '57cd4548-cbe3-42b3-aa13-97821713e307',
    );

    //  console.debug('sessionUser', sessionUser)

    // TODO do this
    /* 

    const { email, password } = answers;
    const loginUrl = new URL(`/api/v1/login`, url).href;
    const response = await fetch(loginUrl, {
    method: 'POST',
    body: JSON.stringify({ email, password }),
    headers: {
    'Content-Type': 'application/json',
    },
    });
    const loginBody = await response.json();
    const header = response.headers.get('set-cookie');
    if (header === null) {
    throw new AuthorizationError(
    `Cannot sign in:\n${JSON.stringify(loginBody)}`,
    );
    }
    const { userUuid } = loginBody.results;
    const cookie = header.split(';')[0].split('=')[1];
    const patUrl = new URL(`/api/v1/user/me/personal-access-tokens`, url).href;
    const now = new Date();
    const description = `Generated by the Lightdash CLI on ${formatDate(now)}`;
    const expiresAt = new Date(now.setDate(now.getDate() + 30));
    const body = JSON.stringify({ expiresAt, description });
    const patResponse = await fetch(patUrl, {
    method: 'POST',
    body,
    headers: {
    'Content-Type': 'application/json',
    Cookie: `connect.sid=${cookie}`,
    },
    });
    */
    /*  await req.login(sessionUser, (args) => {
        
        console.debug('sessionUser', args)
        // console.debug('req', req)
        //  console.debug('req cookie', req.headers.cookie)

        // const r = await fetch('http://localhost:3000/api/v1/user')
        // const loginBody = await response.json();
        // console.debug('loginBody', loginBody)

        // console.debug('r', r)

    })
    const signed = 's:' + signature.sign(req.sessionID, lightdashConfig.lightdashSecret);
    const connectSid = cookie.serialize('connect.sid', signed,req.session.cookie);
    //console.debug('data', data)
    console.debug('connectSid', connectSid) */

    return '';
};
// Extra endpoints for headless-chrome testing on Render
// if (process.env.IS_PULL_REQUEST === 'true') {
headlessBrowserRouter.get('/callback/:flag', async (req, res, next) => {
    // Returns json with the same argument specified in flag
    // Wait a random number of seconds between 0 an 1, to ensure the response can overlap with other requests.
    const delay = Math.floor(Math.random() * 1000);
    setTimeout(() => {
        res.json({
            flag: req.params.flag,
            delay,
        });
    }, delay);
});

headlessBrowserRouter.get('/test/:flag', async (req, res, next) => {
    let browser;

    try {
        const browserWSEndpoint = `ws://${process.env.HEADLESS_BROWSER_HOST}:${process.env.HEADLESS_BROWSER_PORT}`;
        console.debug(`Headless chrome endpoint: ${browserWSEndpoint}`);
        browser = await puppeteer.connect({
            browserWSEndpoint,
        });

        const page = await browser.newPage();
        const hostname =
            process.env.NODE_ENV === 'development'
                ? 'lightdash-dev'
                : process.env.RENDER_SERVICE_NAME;

        const testUrl = `http://${hostname}:${
            process.env.PORT || 3000
        }/api/v1/headless-browser/callback/${req.params.flag}`;
        console.debug(`Fetching headless chrome URL: ${testUrl}`);

        const response = await page.goto(
            'http://lightdash-dev:3000/projects/3675b69e-8324-4110-bdca-059031aa8da3/dashboards/a972e221-f022-448c-8c14-14f89f9470c7/view',
            {},
        );
        const result = await response.json();

        res.json({
            response: result,
            request: {
                flag: req.params.flag,
                browser: browserWSEndpoint,
                url: testUrl,
            },
        });
    } catch (e) {
        console.error(e);
        next(e.message);
    } finally {
        if (browser) await browser.close();
    }
});

headlessBrowserRouter.get('/user/', async (req, res, next) => {
    let browser;

    const url = 'http://lightdash-dev:3000/api/v1/user';
    try {
        const connectSid = getConnectionSid(
            '57cd4548-cbe3-42b3-aa13-97821713e307',
        );

        const browserWSEndpoint = `ws://${process.env.HEADLESS_BROWSER_HOST}:${process.env.HEADLESS_BROWSER_PORT}`;
        console.debug(`Headless chrome endpoint: ${browserWSEndpoint}`);
        browser = await puppeteer.connect({
            browserWSEndpoint,
        });

        const page = await browser.newPage();
        await page.setExtraHTTPHeaders({ cookie: connectSid });

        const response = await page.goto(url, {});
        const result = await response.json();

        res.json(result);
    } catch (e) {
        console.error(e);
        next(e.message);
    } finally {
        if (browser) await browser.close();
    }
});

headlessBrowserRouter.get('/image/', async (req, res, next) => {
    let browser;

    const url =
        'http://lightdash-dev:3000/projects/3675b69e-8324-4110-bdca-059031aa8da3/dashboards/a972e221-f022-448c-8c14-14f89f9470c7/view';
    try {
        const connectSid = getConnectionSid(
            '57cd4548-cbe3-42b3-aa13-97821713e307',
        );

        const browserWSEndpoint = `ws://${process.env.HEADLESS_BROWSER_HOST}:${process.env.HEADLESS_BROWSER_PORT}`;
        console.debug(`Headless chrome endpoint: ${browserWSEndpoint}`);
        browser = await puppeteer.connect({
            browserWSEndpoint,
        });

        passport.authenticate('local');

        const page = await browser.newPage();
        await page.setExtraHTTPHeaders({
            cookie: 'connect.sid=s%3AvJJCUqbRzIXbinMg7vuZOgxIRtlY9leO.4w73M%2Bn9Nut22rc0E2b%2FJa4nFcJdAIRjEUo44qYDc4c',
        });

        await page.setViewport({
            width: 1024,
            height: 768, // hardcoded
        });

        const blockedUrls = [
            'headwayapp.co',
            'rudderlabs.com',
            'analytics.lightdash.com',
            'cohere.so',
            'intercom.io',
        ];
        await page.setRequestInterception(true);
        page.on('request', (request: any) => {
            const requestUrl = request.url();
            if (blockedUrls.includes(requestUrl)) {
                request.abort();
                return;
            }

            request.continue();
        });
        await page.goto(url, {
            timeout: 100000,
            waitUntil: 'networkidle0',
        });

        const imageBuffer = await page.screenshot({
            path: '/tmp/test-screenshot.png',
            clip: { x: 0, y: 0, width: 1024, height: 768 },
        });

        res.writeHead(200, {
            'Content-Type': 'image/png',
            'Content-Length': imageBuffer.length,
        });
        res.end(imageBuffer);
    } catch (e) {
        console.error(e);
        next(e.message);
    } finally {
        if (browser) await browser.close();
    }
});

// }
